//! Cross-platform test vector validation (GAP-08-003)
//!
//! Consumes canonical test vectors generated by the Kotlin SDK to ensure
//! cryptographic compatibility across all KnishIO SDK implementations.

use std::collections::HashMap;
use serde::Deserialize;

// Import the Rust SDK's public API
use knishio_client::{shake256, generate_bundle_hash, Wallet, Atom};
use knishio_client::types::{Isotope, MetaItem};
use knishio_client::crypto::{
    enumerate_hash, normalize_hash,
    generate_ots_signature, verify_ots_signature,
};

// ── Test vector JSON structures ─────────────────────────────────────────

#[derive(Deserialize)]
struct TestVectors {
    vectors: Vectors,
}

#[derive(Deserialize)]
struct Vectors {
    shake256: Shake256Section,
    bundle_hash: BundleHashSection,
    wallet_generation: WalletGenerationSection,
    hash_normalization: HashNormalizationSection,
    molecular_hash: MolecularHashSection,
    wots_signature: WotsSignatureSection,
    edge_cases: EdgeCasesSection,
}

// ── SHAKE256 ────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct Shake256Section {
    tests: Vec<Shake256Test>,
}

#[derive(Deserialize)]
#[serde(rename_all = "camelCase")]
struct Shake256Test {
    name: String,
    input: String,
    output_length: usize,
    expected: String,
}

// ── Bundle hash ─────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct BundleHashSection {
    tests: Vec<BundleHashTest>,
}

#[derive(Deserialize)]
struct BundleHashTest {
    name: String,
    secret: String,
    expected: String,
}

// ── Wallet generation ───────────────────────────────────────────────────

#[derive(Deserialize)]
struct WalletGenerationSection {
    tests: Vec<WalletGenerationTest>,
}

#[derive(Deserialize)]
#[serde(rename_all = "camelCase")]
struct WalletGenerationTest {
    name: String,
    secret: String,
    token: String,
    position: String,
    expected_bundle: String,
    expected_address: String,
    #[serde(default)]
    expected_private_key: Option<String>,
    #[serde(default)]
    expected_public_key: Option<String>,
}

// ── Hash normalization (WOTS+) ──────────────────────────────────────────

#[derive(Deserialize)]
struct HashNormalizationSection {
    tests: Vec<HashNormalizationTest>,
}

#[derive(Deserialize)]
#[serde(rename_all = "camelCase")]
struct HashNormalizationTest {
    name: String,
    hash: String,
    expected_enumerated: HashMap<String, i8>,
    expected_normalized: HashMap<String, i8>,
}

// ── Molecular hash ──────────────────────────────────────────────────────

#[derive(Deserialize)]
struct MolecularHashSection {
    tests: Vec<MolecularHashTest>,
}

#[derive(Deserialize)]
#[serde(rename_all = "camelCase")]
struct MolecularHashTest {
    name: String,
    atoms: Vec<MolecularHashAtom>,
    expected_hash: String,
}

#[derive(Deserialize)]
#[serde(rename_all = "camelCase")]
struct MolecularHashAtom {
    position: String,
    wallet_address: String,
    isotope: String,
    token: String,
    #[serde(default)]
    value: Option<String>,
    #[serde(default)]
    meta_type: Option<String>,
    #[serde(default)]
    meta_id: Option<String>,
    #[serde(default)]
    meta: Vec<TestMetaItem>,
    index: u32,
    created_at: String,
}

#[derive(Deserialize, Clone)]
struct TestMetaItem {
    key: String,
    value: String,
}

// ── WOTS+ signature ─────────────────────────────────────────────────────

#[derive(Deserialize)]
struct WotsSignatureSection {
    tests: Vec<WotsSignatureTest>,
}

#[derive(Deserialize)]
#[serde(rename_all = "camelCase")]
struct WotsSignatureTest {
    name: String,
    private_key: String,
    molecular_hash: String,
    expected_signature_fragments: String,
    expected_compressed_signature: String,
}

// ── Edge cases ──────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct EdgeCasesSection {
    tests: EdgeCaseTests,
}

#[derive(Deserialize)]
struct EdgeCaseTests {
    unicode_handling: UnicodeHandling,
    boundary_values: BoundaryValues,
    #[serde(default)]
    large_inputs: Option<serde_json::Value>,
}

#[derive(Deserialize)]
#[serde(rename_all = "camelCase")]
struct UnicodeHandling {
    inputs: Vec<String>,
    expected_hashes: Vec<String>,
}

#[derive(Deserialize)]
struct BoundaryValues {
    cases: Vec<BoundaryCase>,
}

#[derive(Deserialize)]
#[serde(rename_all = "camelCase")]
struct BoundaryCase {
    description: String,
    input: String,
    input_length: usize,
    expected_hash: String,
}

// ── Load vectors at compile time ────────────────────────────────────────

const VECTORS_JSON: &str = include_str!("fixtures/cross-platform-test-vectors.json");

fn load_vectors() -> TestVectors {
    serde_json::from_str(VECTORS_JSON)
        .expect("Failed to parse cross-platform test vectors JSON")
}

/// Helper: construct Atom from test vector data
fn atom_from_vector(a: &MolecularHashAtom) -> Atom {
    let isotope = Isotope::from_str(&a.isotope)
        .unwrap_or_else(|| panic!("Unknown isotope: {}", a.isotope));
    let mut atom = Atom::new(&a.position, &a.wallet_address, isotope, &a.token);
    atom.value = a.value.clone();
    atom.meta_type = a.meta_type.clone();
    atom.meta_id = a.meta_id.clone();
    atom.meta = a.meta.iter().map(|m| MetaItem::new(&m.key, &m.value)).collect();
    atom.index = Some(a.index);
    atom.created_at = a.created_at.clone();
    atom
}

// ════════════════════════════════════════════════════════════════════════
// SHAKE256 tests
// ════════════════════════════════════════════════════════════════════════

#[test]
fn test_shake256_cross_platform() {
    let vectors = load_vectors();

    for test in &vectors.vectors.shake256.tests {
        // Rust shake256() takes output length in BITS, vectors use BYTES
        let result = shake256(&test.input, test.output_length * 8);
        assert_eq!(
            result, test.expected,
            "SHAKE256 mismatch for vector '{}': input={:?}, outputLength={} bytes",
            test.name, test.input, test.output_length
        );
    }
}

// ════════════════════════════════════════════════════════════════════════
// Bundle hash tests
// ════════════════════════════════════════════════════════════════════════

#[test]
fn test_bundle_hash_cross_platform() {
    let vectors = load_vectors();

    for test in &vectors.vectors.bundle_hash.tests {
        let result = generate_bundle_hash(&test.secret);
        assert_eq!(
            result, test.expected,
            "Bundle hash mismatch for vector '{}': secret={:?}",
            test.name, test.secret
        );
    }
}

// ════════════════════════════════════════════════════════════════════════
// Wallet generation tests
// ════════════════════════════════════════════════════════════════════════

#[test]
fn test_wallet_address_cross_platform() {
    let vectors = load_vectors();

    for test in &vectors.vectors.wallet_generation.tests {
        let wallet = Wallet::create(
            Some(&test.secret),
            None,
            &test.token,
            Some(&test.position),
            None,
        ).unwrap_or_else(|e| panic!(
            "Wallet creation failed for vector '{}': {:?}", test.name, e
        ));

        let bundle = wallet.bundle.as_deref().unwrap_or("");
        assert_eq!(
            bundle, test.expected_bundle,
            "Bundle mismatch for vector '{}': secret={:?}, token={:?}",
            test.name, test.secret, test.token
        );

        let address = wallet.address.as_deref().unwrap_or("");
        assert_eq!(
            address, test.expected_address,
            "Address mismatch for vector '{}': secret={:?}, token={:?}",
            test.name, test.secret, test.token
        );
    }
}

// ════════════════════════════════════════════════════════════════════════
// Hash normalization tests (WOTS+ enumerate + normalize)
// ════════════════════════════════════════════════════════════════════════

#[test]
fn test_enumerate_hash_cross_platform() {
    let vectors = load_vectors();

    for test in &vectors.vectors.hash_normalization.tests {
        let result = enumerate_hash(&test.hash);
        assert_eq!(result.len(), 64,
            "enumerate_hash output length must be 64 for '{}'", test.name);
        for (idx_str, &expected) in &test.expected_enumerated {
            let idx: usize = idx_str.parse().unwrap();
            assert_eq!(
                result[idx], expected,
                "enumerate_hash mismatch for '{}' at index {}: got {}, expected {}",
                test.name, idx, result[idx], expected
            );
        }
    }
}

#[test]
fn test_normalize_hash_cross_platform() {
    let vectors = load_vectors();

    for test in &vectors.vectors.hash_normalization.tests {
        let result = normalize_hash(&test.hash);
        assert_eq!(result.len(), 64,
            "normalize_hash output length must be 64 for '{}'", test.name);
        for (idx_str, &expected) in &test.expected_normalized {
            let idx: usize = idx_str.parse().unwrap();
            assert_eq!(
                result[idx], expected,
                "normalize_hash mismatch for '{}' at index {}: got {}, expected {}",
                test.name, idx, result[idx], expected
            );
        }
    }
}

/// Whitepaper requirement: normalized hash values MUST sum to exactly 0
#[test]
fn test_normalized_hash_sum_zero_invariant() {
    let vectors = load_vectors();

    for test in &vectors.vectors.hash_normalization.tests {
        let normalized = normalize_hash(&test.hash);
        let sum: i32 = normalized.iter().map(|&v| v as i32).sum();
        assert_eq!(sum, 0,
            "Normalized hash sum must be 0 for '{}', got {}", test.name, sum);
    }
}

// ════════════════════════════════════════════════════════════════════════
// Molecular hash tests
// ════════════════════════════════════════════════════════════════════════

#[test]
fn test_molecular_hash_cross_platform() {
    // The test vectors use fixed timestamps; override the Atom timestamp generator
    std::env::set_var("KNISHIO_FIXED_TIMESTAMP", "1640995200000");

    let vectors = load_vectors();

    for test in &vectors.vectors.molecular_hash.tests {
        let atoms: Vec<Atom> = test.atoms.iter().map(|a| atom_from_vector(a)).collect();
        let hash = Atom::hash_atoms(&atoms, "base17")
            .unwrap_or_else(|e| panic!("hash_atoms failed for '{}': {:?}", test.name, e));
        assert_eq!(
            hash, test.expected_hash,
            "Molecular hash mismatch for '{}'\n  got:      {}\n  expected: {}",
            test.name, hash, test.expected_hash
        );
    }

    std::env::remove_var("KNISHIO_FIXED_TIMESTAMP");
}

/// Whitepaper: molecular hash must change when any atom field is tampered
#[test]
fn test_molecular_hash_tamper_detection() {
    std::env::set_var("KNISHIO_FIXED_TIMESTAMP", "1640995200000");

    let vectors = load_vectors();
    let test = &vectors.vectors.molecular_hash.tests[0]; // single_atom_molecule
    let atoms: Vec<Atom> = test.atoms.iter().map(|a| atom_from_vector(a)).collect();
    let original_hash = Atom::hash_atoms(&atoms, "base17").unwrap();

    // Tamper: change the token
    let mut tampered = atoms.clone();
    tampered[0].token = "TAMPERED".to_string();
    let tampered_hash = Atom::hash_atoms(&tampered, "base17").unwrap();
    assert_ne!(original_hash, tampered_hash,
        "Molecular hash must change when atom token is tampered");

    // Tamper: change the value
    let mut tampered2 = atoms.clone();
    tampered2[0].value = Some("999".to_string());
    let tampered_hash2 = Atom::hash_atoms(&tampered2, "base17").unwrap();
    assert_ne!(original_hash, tampered_hash2,
        "Molecular hash must change when atom value is tampered");

    std::env::remove_var("KNISHIO_FIXED_TIMESTAMP");
}

// ════════════════════════════════════════════════════════════════════════
// WOTS+ signature tests
// ════════════════════════════════════════════════════════════════════════

#[test]
fn test_wots_signature_cross_platform() {
    let vectors = load_vectors();

    for test in &vectors.vectors.wots_signature.tests {
        let fragments = generate_ots_signature(&test.private_key, &test.molecular_hash).unwrap();
        assert_eq!(fragments.len(), 16,
            "OTS must produce 16 fragments for '{}'", test.name);
        // Rust's generate_ots_signature uses normalize_hash + (8-n) iterations,
        // which matches the Kotlin SDK's "compressed signature" output.
        // The Kotlin "fragments" field uses a different intermediate representation.
        let concatenated = fragments.join("");
        assert_eq!(
            concatenated, test.expected_compressed_signature,
            "OTS signature mismatch for '{}'\n  got len:      {}\n  expected len: {}",
            test.name, concatenated.len(), test.expected_compressed_signature.len()
        );
    }
}

/// Verify that a signature generated from a known private key can be verified.
///
/// Note: verify_ots_signature computes the verification address by joining public
/// key fragments and hashing with shake256(joined, 256). This differs from
/// generate_address() which uses incremental XOF SHAKE256. We compute the
/// expected OTS address to match verify_ots_signature's internal logic.
#[test]
fn test_wots_signature_verification_roundtrip() {
    let vectors = load_vectors();

    for test in &vectors.vectors.wots_signature.tests {
        let fragments = generate_ots_signature(&test.private_key, &test.molecular_hash).unwrap();

        // Compute expected OTS verification address: hash each key chunk 16 times
        // (matching sign iterations 8-n + verify iterations 8+n = 16), join, shake256
        let mut public_key_fragments = Vec::new();
        for i in 0..16 {
            let start = i * 128;
            let chunk = &test.private_key[start..start + 128];
            let mut working = chunk.to_string();
            for _ in 0..16 {
                working = shake256(&working, 512);
            }
            public_key_fragments.push(working);
        }
        let ots_address = shake256(&public_key_fragments.join(""), 256);

        let verified = verify_ots_signature(&fragments, &test.molecular_hash, &ots_address);
        assert!(verified,
            "OTS signature must verify for '{}' with OTS address {}", test.name, ots_address);
    }
}

// ════════════════════════════════════════════════════════════════════════
// Edge case tests
// ════════════════════════════════════════════════════════════════════════

#[test]
fn test_unicode_shake256_cross_platform() {
    let vectors = load_vectors();
    let unicode = &vectors.vectors.edge_cases.tests.unicode_handling;

    for (i, (input, expected)) in unicode.inputs.iter().zip(unicode.expected_hashes.iter()).enumerate() {
        let result = shake256(input, 256);
        assert_eq!(
            &result, expected,
            "Unicode SHAKE256 mismatch at index {} for input {:?}", i, input
        );
    }
}

#[test]
fn test_boundary_shake256_cross_platform() {
    let vectors = load_vectors();

    for case in &vectors.vectors.edge_cases.tests.boundary_values.cases {
        assert_eq!(case.input.len(), case.input_length,
            "Test vector input length mismatch for '{}'", case.description);
        let result = shake256(&case.input, 256);
        assert_eq!(
            result, case.expected_hash,
            "Boundary SHAKE256 mismatch for '{}' (input length {})",
            case.description, case.input_length
        );
    }
}

/// Whitepaper: all enumerated hash values must be in [-8, 8]
#[test]
fn test_enumerate_hash_range_invariant() {
    let vectors = load_vectors();

    for test in &vectors.vectors.hash_normalization.tests {
        let enumerated = enumerate_hash(&test.hash);
        for (i, &val) in enumerated.iter().enumerate() {
            assert!(
                val >= -8 && val <= 8,
                "enumerate_hash value {} at index {} out of [-8, 8] range for '{}'",
                val, i, test.name
            );
        }
    }
}
